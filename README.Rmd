---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
library(gridlayout)
```

# gridlayout

<!-- badges: start -->
<!-- badges: end -->

A package to making building weblayouts using CSS-Grid easy.

## Installation

You can install the development version from [GitHub](https://github.com/) with:

``` r
# install.packages("devtools")
devtools::install_github("rstudio/gridlayout")
```

## Setting up your `gridlayout`

The easiest and most common way to specify a grid layout is using a markdown table syntax. This allows you to use any markdown table editor of your choice to configure your layout. 

```{r md_to_gridlayout}
my_layout <- md_to_gridlayout(
  layout_table = "
    |      |120px   |1fr    |1fr    |
    |------|--------|-------|-------|
    |100px |header  |header |header |
    |1fr   |sidebar |plot_a |plot_c |
    |1fr   |sidebar |plot_b |plot_b |"
)

my_layout
```

You can also use the top left cell of your table to specify the gap size.

```{r md_to_gridlayout_w_gap}
my_layout <- md_to_gridlayout(
  layout_table = "
    | 25px |120px   |1fr    |1fr    |
    |------|--------|-------|-------|
    |100px |header  |header |header |
    |1fr   |sidebar |plot_a |plot_c |
    |1fr   |sidebar |plot_b |plot_b |"
)

my_layout
```

You can also programatically build your layout using `new_gridlayout`. Here you simply pass a list of the elements that make up your layout along with column and row sizes.

```{r new_gridlayout}
library(gridlayout)

# Assemble list of elements along with their positions
elements_list <- list(
  list(id = "header", start_row = 1, end_row = 1,
       start_col = 1, end_col = 2),
  list(id = "plot",   start_row = 2, end_row = 2,
       start_col = 1, end_col = 1),
  list(id = "table",  start_row = 2, end_row = 2,
       start_col = 2, end_col = 2),
  list(id = "footer", start_row = 3, end_row = 3,
       start_col = 1, end_col = 2)
)

new_gridlayout(
  col_sizes = c("1fr", "2fr"),
  row_sizes = c("100px", "1fr", "1fr"),
  element_list = elements_list
)

```

Alternatively, you can use a matrix for a more visually intuitive layout system (although `my_to_gridlayout()` is even better.)

```{r new_gridlayout_matrix}
elements_mat <- matrix(c(
  "header", "header",
  "plot",   "table",
  "footer", "footer"),
  ncol = 2, byrow = TRUE
)

new_gridlayout(
  col_sizes = c("1fr", "2fr"),
  row_sizes = c("100px", "1fr", "1fr"),
  layout_mat = elements_mat
)
```



You can also build a layout from a markdown documents that have your layout in a code-chunk. This is useful for updating existing applications layouts without copying and pasting your layout table.


__`my_app.rmd`__
````
``` {.layout .grid}
| sidebar | main |
|---------|------|
| sidebar | main |
```

## Sidebar title here {#sidebar}

Here's a sentence at the top of the sidebar.

``` {.r .ui}
tagList(
  sliderInput('x', 'X:', 1, 10, 5),
  textInput('txt', 'Input text')
)
```

------------------------------------------------------------------------

More text in the sidebar.
...
````

````{r}
my_app_loc <- system.file("sample_apps/my_app.Rmd", package = "gridlayout")
my_layout <- rmd_to_gridlayout(my_app_loc)
my_layout
````

## Using in a shiny app

Once you've setup your layout you can use it in a Shiny app with the `grid_page()` ui function:

```{r, eval = FALSE}
library(shiny)

my_layout <- "
|      |        |       |
|------|--------|-------|
|2rem  |200px   |1fr    |
|150px |header  |header |
|1fr   |sidebar |plot   |"

# The classic Geyser app with grid layout
shinyApp(
  ui = grid_page(
    layout = my_layout,
    header = h2("Old Faithful Geyser Data"),
    sidebar = sliderInput("bins","Number of bins:", min = 1, max = 50, value = 30),
    plot = plotOutput("distPlot", height = "100%")
  ),
  server = function(input, output) {
    output$distPlot <- renderPlot({
      x    <- faithful[, 2]
      bins <- seq(min(x), max(x), length.out = input$bins + 1)
      hist(x, breaks = bins, col = 'darkgray', border = 'white')
    })
  }
)
```

```{r, echo = FALSE, message=FALSE}
my_layout <- "
|      |        |       |
|------|--------|-------|
|2rem  |200px   |1fr    |
|150px |header  |header |
|1fr   |sidebar |plot   |"
app_obj <- shiny::shinyApp(
  ui = grid_page(
    layout = my_layout,
    header = shiny::h2("Old Faithful Geyser Data"),
    sidebar = shiny::sliderInput("bins","Number of bins:", min = 1, max = 50, value = 30),
    plot = shiny::plotOutput("distPlot", height = "100%")
  ),
  server = function(input, output) {
    output$distPlot <- shiny::renderPlot({
      x    <- faithful[, 2]
      bins <- seq(min(x), max(x), length.out = input$bins + 1)
      hist(x, breaks = bins, col = 'darkgray', border = 'white')
    })
  }
)

screenshot_path <- tempfile(fileext = ".png")

webshot2::appshot(
  app = app_obj,
  file = screenshot_path,
  vwidth = 1600,
  vheight = 1200,
  cliprect = "viewport"
)

knitr::include_graphics(screenshot_path)
```



`grid_page()` will automatically make your gridlayout fill the entire page. If you are interested in having a finer-grain control over the size and position of your grid layout you can use the `grid_container()` function to place your grid layout wherever you want. The equivalent app to above can be created by replacing the UI definition with a `fluidPage` containing a `grid_container()`:

```{r, eval = FALSE}
...
shinyApp(
  ui = fluidPage(
    theme = bslib::bs_theme(),
    grid_container(
      id = "main_grid",
      layout = my_layout,
      container_height = "800px",
      elements = list(
        header = h2(id = "header", "This is my header content"),
        sidebar = sliderInput("bins","Number of bins:", min = 1, max = 50, value = 30),
        plot = plotOutput("distPlot", height = "100%")
      )
    )
  ),
  server = ...
)
```

This time, however the grid is constrained to `800px` tall, no-matter how large or small the window viewing it is. 

## Working with layout object

Once you have your `gridlayout` object, you can convert it to a markdown table spec or to the CSS that generates the given grid.

```{r to_md}
cat(to_md(my_layout))
```

```{r to_css}
cat(to_css(my_layout))
```

If you want to get at the individual components or "elements" stored in your grid you can use `get_elements()`.

```{r get_elements}
head(get_elements(my_layout), 2)
```

